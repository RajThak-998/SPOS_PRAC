------------------------------------------------------PASS1&2 ASSEMBLER------------------------------------------------

Topic 1: Assembler (Two-Pass Assembler)
üîπ 1. What is an Assembler?

An assembler is a system program that translates assembly language (human-readable mnemonics) into machine code (binary instructions) that the CPU can execute.

Example:
Assembly Code	Meaning	Machine Code (Example)
MOV A, B	Move contents of B to A	78
ADD A, C	Add contents of C to A	81

The assembler converts such mnemonics into corresponding binary opcodes.

üîπ 2. Types of Assemblers
Type	Description
One-pass assembler	Assembles source code in one scan. Faster, but cannot handle forward references.
Two-pass assembler	Scans the program twice ‚Äî once to collect information (symbols, addresses), and second to generate actual code. Handles forward references easily.

You‚Äôll be implementing a Two-Pass Assembler in your practical.

üîπ 3. Phases of Assembler

A two-pass assembler has the following general structure:

Pass-I (Analysis Phase)

Reads source program line by line.

Builds Symbol Table (SYMTAB).

Builds Literal Table (LITTAB).

Generates Intermediate Code (IC).

Calculates Location Counter (LC) for each instruction.

Pass-II (Synthesis Phase)

Takes Intermediate Code (IC) and Symbol Tables as input.

Generates Machine Code / Object Code.

Resolves addresses using symbol and literal tables.

üîπ 4. Data Structures Used
Table	Full Name	Purpose
MOT	Machine Opcode Table	Stores mnemonics and their binary opcodes, instruction length, etc.
POT	Pseudo Opcode Table	Stores assembler directives like START, END, ORIGIN, EQU, LTORG, etc.
SYMTAB	Symbol Table	Keeps track of labels and their corresponding addresses.
LITTAB	Literal Table	Stores constants/literals used in the program (e.g., =‚Äò5‚Äô).
POOLTAB	Pool Table	Used to manage groups of literals between LTORG/END.
IC	Intermediate Code	Temporary representation of the program. Used as input for Pass-II.
üîπ 5. Important Assembler Directives
Directive	Meaning
START	Specifies starting address of the program
END	Marks end of source program
ORIGIN	Specifies new value of location counter
EQU	Assigns value to a symbol
LTORG	Assembles all literals accumulated so far
DS	Define Storage (reserves memory)
DC	Define Constant (assigns value)
üîπ 6. Pass-I Algorithm (Step-wise)

Initialize LC = starting address (from START directive).

Read one line of source code at a time.

If the line has a label, enter it in SYMTAB with current LC.

If it‚Äôs a Mnemonic (in MOT) ‚Üí increment LC by instruction length.

If it‚Äôs a Directive (in POT) ‚Üí perform appropriate action:

DS ‚Üí allocate memory

DC ‚Üí assign value

EQU ‚Üí define symbol

LTORG or END ‚Üí assign addresses to literals and update POOLTAB.

If it has Literals, add them to LITTAB.

Generate Intermediate Code (opcode class, symbol reference, literal ref, etc.).

Repeat till END.

Output of Pass-I:

SYMTAB, LITTAB, POOLTAB, IC

üîπ 7. Pass-II Algorithm (Step-wise)

Read IC generated by Pass-I.

For each instruction:

Get the opcode from MOT.

Replace symbols/literals with their addresses from SYMTAB or LITTAB.

Generate Machine Code (opcode + address).

Continue until END.

Output of Pass-II:

Machine Code (Object Program) ready for execution.

üîπ 8. Example
Input Assembly Code
START 200
MOVER AREG, A
ADD BREG, ONE
MOVEM AREG, B
A DS 1
B DS 1
ONE DC 1
END

Pass-I Output
Symbol	Address
A	202
B	203
ONE	204
Literal	Address
‚Äî	‚Äî

Intermediate Code (IC) (simplified example):

(AD,01) (C,200)
(IS,04) (1)(S,1)
(IS,01) (2)(S,3)
(IS,05) (1)(S,2)
(DL,01) (C,1)
(DL,01) (C,1)
(DL,02) (C,1)
(AD,02)

Pass-II Output (Machine Code Example)
04 01 202
01 02 204
05 01 203
-- Data Definitions --

üîπ 9. Viva / Oral Preparation Tips

‚úÖ What is an assembler?
‚úÖ Why two passes are needed?
‚úÖ What are SYMTAB, LITTAB, MOT, POT, IC?
‚úÖ Difference between machine opcode and pseudo opcode.
‚úÖ Role of LTORG, EQU, ORIGIN.
‚úÖ How addresses are resolved in Pass-II.




--------------------------------------MACRO 1&2------------------------------------------------------

Macro Processor ‚Äì Pass 1 & Pass 2 (Clear & Crisp Explanation)

A macro processor generally works in two passes.
The main goal:

Pass 1: Understand & store the macro.

Pass 2: Expand the macro during program execution.

‚úÖ PASS 1 ‚Äî Macro Definition Processing

Purpose:
Identify macro definitions and store all required information for later expansion.

What happens in Pass 1:

Detect MACRO‚ÄìMEND block

Whenever the assembler sees the keyword MACRO, Pass 1 enters ‚Äúmacro definition mode‚Äù.

Add macro name in MDT & MNT

MNT (Macro Name Table): Stores macro name + pointer to its definition.

MDT (Macro Definition Table): Stores actual macro body line-by-line.

Assign parameters indexes

Positional parameters &A, &B converted into #1, #2 etc.

Stored in ALA (Argument List Array).

Ignore macro expansion

Pass 1 does NOT expand macros.

It only stores the macro so pass 2 can expand it.

End result of Pass 1:

Macro names + their bodies + parameter mapping are stored in tables.

The macro body is not executed yet.

‚úÖ PASS 2 ‚Äî Macro Expansion

Purpose:
Use the stored macro definition and replace macro calls in the source code with expanded code.

What happens in Pass 2:

Scan program for macro calls

When a macro invocation appears, Pass 2 uses MNT to locate its definition.

Build ALA for actual arguments

Actual parameters in the macro call replace the positional indexes (#1, #2, ...).

Expand macro

The macro body from MDT is copied into the output program.

Each positional argument is replaced with actual argument.

Proceed like normal assembly

After expansion, the assembler processes the expanded code like any other instruction.

End result of Pass 2:

Complete program with all macros expanded.

This output is passed to assembler for final assembly.

üìå Example (Easy to Explain)
Source:
MACRO
ADDME &A,&B
LDA &A
ADD &B
STA RESULT
MEND

ADDME X,Y

Pass 1 creates:

MNT:

Macro	MDT Ptr
ADDME	1

MDT:
1: LDA #1
2: ADD #2
3: STA RESULT

ALA:
#1 ‚Üí &A
#2 ‚Üí &B

Pass 2 expands:

ADDME X,Y becomes:

LDA X
ADD Y
STA RESULT

üéØ One-line crisp answers (for viva)

Pass 1:
‚ÄúPass 1 stores macro definitions in tables (MNT, MDT, ALA) and does not expand them.‚Äù

Pass 2:
‚ÄúPass 2 expands the macros by replacing macro calls with their stored definitions using actual parameters.‚Äù







-------------------------------------DLL--------------------------------------------------

DLL (Dynamic Link Library) ‚Äî Clear & Practical Explanation
1. What is a DLL? (Teacher-friendly definition)

A Dynamic Link Library is a file that contains compiled code (functions) that can be loaded at runtime by any program.
In Windows this file ends with .dll; in Linux, it‚Äôs .so.

It lets multiple programs share the same functions without copying code everywhere.

2. Why do we need a DLL in JNI?

In Java, when you use native methods, Java itself cannot execute that code directly.
Java needs a bridge to execute C/C++ functions ‚Äî and that bridge is provided through a DLL.

So when your Java file declares:

public native int add(int a, int b);


Java says:
"I will call this function from an external library ‚Äî you give me the native implementation."

That implementation is written in C ‚Üí compiled ‚Üí becomes a DLL ‚Üí loaded using:

System.loadLibrary("xyz");

3. How the Pipeline Works (Step-by-step flow)

This is exactly what to tell in viva:

Write Java file with a native method

Compile Java file ‚Üí generate .class

Use javac -h . to generate header (.h)

Write C file that implements the function defined in the header

Compile C file into a DLL file (.dll)

Run Java program ‚Üí JVM loads DLL ‚Üí calls C code

This is the entire JNI‚ÄìDLL workflow.

4. What happens internally (Short but strong explanation)

Java creates a JNI environment pointer which points to JVM internals.

When Java calls the native method, JVM looks for the matching C function name inside the DLL.

The C function executes and returns result back to Java through JNI.

This shows you understand what‚Äôs going on beyond just running commands.

5. Your Program Explanation (General Template)

Here is how you explain YOUR code when teacher asks ‚ÄúExplain what your code does‚Äù:

Java File (Main.java)

Contains a class with a native method.

Loads the DLL using System.loadLibrary.

Calls the native function to demonstrate DLL linking.

Header File (Main.h)

Auto-generated using:
javac -h . Main.java

Contains function signature in JNI format:

Java_Main_add(JNIEnv*, jobject, jint, jint);

C File (Main.c)

Implements the function declared in the header.

Uses JNI naming conventions.

Returns value back to Java.

DLL

Created using gcc:
gcc -shared -o mydll.dll Main.c -I<jdk>/include -I<jdk>/include/win32

JVM loads this DLL at runtime.

6. Crisp Viva Answers
‚ùì Why do we create a DLL?

Because Java cannot run C code directly, so native methods are compiled into a DLL which JVM loads at runtime.

‚ùì What is JNI?

Java Native Interface ‚Äî a mechanism that allows Java to call C/C++ code using dynamic libraries.

‚ùì What is the role of the header file?

It defines the exact C function signature expected by JVM, ensuring correct linking.

‚ùì What command generates the header?

javac -h . Main.java

‚ùì What command generates the DLL?

Windows (Mingw):

gcc -shared -o mydll.dll Main.c -I<jdk>/include -I<jdk>/include/win32


Linux:

gcc -shared -fPIC -o libmydll.so Main.c -I<jdk>/include -I<jdk>/include/linux

‚ùì How does JVM find the DLL?

Using System.loadLibrary("name") ‚Äî without file extension.

7. Super-Crisp Summary (30-second explanation)

‚ÄúDLL is a compiled C library that Java loads at runtime to execute native methods. Using JNI, Java calls the C functions defined inside the DLL. The process: write Java ‚Üí compile ‚Üí generate header ‚Üí write C code ‚Üí compile into DLL ‚Üí run Java. JVM loads the DLL and executes the C code when the native method is invoked.‚Äù

------------------------------------DLL command ------------------------------------------------------------------
Full Command
gcc -fPIC -I"$(dirname $(readlink -f $(which javac)))/../include" \
    -I"$(dirname $(readlink -f $(which javac)))/../include/linux" \
    -shared -o libAddLib.so AddLib.c

‚úÖ High-level purpose

This GCC command compiles C code (AddLib.c) into a shared library (.so) that Java can use through JNI.

Your output is:

libAddLib.so

‚úÖ Breakdown of each part
1. gcc

The GNU C compiler ‚Äî compiles your C code.

2. -fPIC

Position Independent Code
Required when creating shared libraries (.so).

Why?
.so files can be loaded at any memory address, so the code must be relocatable.

If you skip this, you get errors like:

relocation R_X86_64‚Ä¶ against `.text‚Äô can not be used when making a shared object

3. -I"<path>" (Include directories)

This tells gcc where to find JNI header files.

Your command has two include paths:

(a) Java include folder
-I "<java-home>/include"


This contains:

jni.h
jni_md.h
jniport.h

(b) OS-specific include folder
-I "<java-home>/include/linux"


This contains OS-dependent JNI definitions.

These two folders are required for ANY JNI compilation.

4. How does the command find Java include path automatically?

This part:

$(which javac)


‚Üí Finds the full path of javac.

Example:

/usr/bin/javac


Then:

readlink -f $(which javac)


‚Üí Resolves the real path (in case it's a symlink).

Then:

dirname <path>


‚Üí Gets the directory path.

Finally:

../include
../include/linux


‚Üí Goes one level up and into the include folders.

So this whole thing dynamically finds your JDK location.

This allows the command to work on any machine without manually specifying JDK path.

5. -shared

This tells gcc:

‚ÄúCreate a shared library (.so), not a normal executable.‚Äù

6. -o libAddLib.so

The output file name.

Linux requires:

Prefix: lib

Extension: .so

Java will load it using:

System.loadLibrary("AddLib");

7. AddLib.c

Your C source file that contains the JNI function implementation.

üéØ Crisp Viva Answer

‚ÄúThis command compiles my AddLib.c into a shared library libAddLib.so. The -fPIC option creates position-independent code, -shared builds a .so, and the -I options include the JNI headers from the JDK. The command automatically detects the JDK path using which, readlink, and dirname.‚Äù
